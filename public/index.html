<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IOC3 Mobile</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            min-height: 100vh;
            /* 基底色，防止渐变加载前短暂闪白 */
            background: linear-gradient(120deg, #0ea5ea 0%, #7367f0 100%);
            overflow: hidden;
        }
        /* 多层径向渐变：三到四种颜色同时出现，并做无规则漂移 */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            z-index: -2;
            background:
                radial-gradient(circle, rgba(255,107,107,0.55), rgba(255,107,107,0.0) 60%),
                radial-gradient(circle, rgba(248,231,28,0.45), rgba(248,231,28,0.0) 60%),
                radial-gradient(circle, rgba(90,200,250,0.50), rgba(90,200,250,0.0) 60%),
                radial-gradient(circle, rgba(88,86,214,0.55), rgba(88,86,214,0.0) 60%);
            background-size: 60% 60%, 70% 70%, 65% 65%, 75% 75%;
            background-position: 10% 20%, 80% 15%, 20% 80%, 75% 75%;
            filter: saturate(120%) blur(10px);
            animation: wander 8s ease-in-out infinite alternate;
        }
        @keyframes wander {
            0%   { background-position: 10% 20%, 80% 15%, 20% 80%, 75% 75%; }
            25%  { background-position: 75% 25%, 20% 70%, 60% 15%, 15% 85%; }
            50%  { background-position: 30% 75%, 65% 20%, 15% 35%, 85% 65%; }
            75%  { background-position: 55% 35%, 25% 85%, 90% 30%, 10% 55%; }
            100% { background-position: 10% 20%, 80% 15%, 20% 80%, 75% 75%; }
        }
        #root {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            width: 100%;
        }
        .mobile-container {
            /* 自适应全宽 */
            margin: 0 auto;
            width: 100%;
            max-width: 100%;
            height: 100%;
            /* 取消设备边框，背景透明以展示渐变 */
            border: none;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            background: transparent;
            z-index: 1; /* 内容显示在画布之上 */
        }
        /* 连接线与点的画布层（位于内容之下，渐变之上） */
        .particles-canvas {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }
        .header {
            /* 让标题也置于渐变之上，不再遮挡背景 */
            background: transparent;
            padding: 16px 12px 12px;
            text-align: center;
            border-bottom: none;
        }
        .header h2 { color: #ffffff; margin: 0; text-shadow: 0 2px 6px rgba(0,0,0,0.35); }
        .content {
            padding: 0 16px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .status-text {
            color: #ffffff;
            text-align: center;
            margin: 0;
            font-size: 16px;
            line-height: 1.6;
            text-shadow: 0 1px 2px rgba(0,0,0,0.35);
        }
    </style>
</head>
<body>
    <!-- 粒子与连线画布层 -->
    <canvas id="particles" class="particles-canvas"></canvas>
    <div id="root">
        <div class="mobile-container">
            <div class="header">
                <h2>业务协作系统</h2>
            </div>
            <div class="content">
                <p class="status-text">系统启动中...</p>
            </div>
        </div>
    </div>
    <script>
        // 这里可以加载实际的React应用
        console.log('移动端模拟器已加载');

        // 简洁高效的点线网络动画（适度密度、无规则变化）
        (function () {
            const canvas = document.getElementById('particles');
            const ctx = canvas.getContext('2d');
            let w = 0, h = 0, dpr = Math.max(1, window.devicePixelRatio || 1);

            function resize() {
                w = window.innerWidth;
                h = window.innerHeight;
                canvas.width = Math.floor(w * dpr);
                canvas.height = Math.floor(h * dpr);
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                initPoints();
            }

            // 适度密度：按面积估算数量，限制范围 28-60
            let points = [];
            function initPoints() {
                const target = Math.max(28, Math.min(60, Math.floor((w * h) / 32000)));
                points = new Array(target).fill(0).map(() => createPoint());
            }

            function rnd(min, max) { return Math.random() * (max - min) + min; }
            function createPoint() {
                const speed = rnd(0.07, 0.22); // 基础速度更快一点
                const dir = rnd(0, Math.PI * 2);
                return {
                    x: rnd(0, w),
                    y: rnd(0, h),
                    vx: Math.cos(dir) * speed,
                    vy: Math.sin(dir) * speed,
                    ax: 0,
                    ay: 0,
                    r: rnd(1.2, 2.0)
                };
            }

            function step() {
                ctx.clearRect(0, 0, w, h);
                // 轻微随机加速度，制造“无规则变化”
                for (let p of points) {
                    p.ax += rnd(-0.015, 0.015);
                    p.ay += rnd(-0.015, 0.015);
                    p.vx = (p.vx + p.ax) * 0.98; // 阻尼防失控
                    p.vy = (p.vy + p.ay) * 0.98;
                    // 限速
                    const vmax = 0.45;
                    p.vx = Math.max(-vmax, Math.min(vmax, p.vx));
                    p.vy = Math.max(-vmax, Math.min(vmax, p.vy));
                    // 移动
                    p.x += p.vx;
                    p.y += p.vy;
                    // 边界回弹
                    if (p.x < 0 || p.x > w) { p.vx *= -1; p.x = Math.max(0, Math.min(w, p.x)); }
                    if (p.y < 0 || p.y > h) { p.vy *= -1; p.y = Math.max(0, Math.min(h, p.y)); }
                    // 轻微衰减加速度
                    p.ax *= 0.9; p.ay *= 0.9;
                }

                // 连接近距离的点
                const linkDist = Math.max(100, Math.min(160, Math.hypot(w, h) * 0.12));
                ctx.lineWidth = 1;
                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    // 画点
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(255,255,255,0.75)';
                    ctx.arc(p1.x, p1.y, p1.r, 0, Math.PI * 2);
                    ctx.fill();

                    for (let j = i + 1; j < points.length; j++) {
                        const p2 = points[j];
                        const dx = p1.x - p2.x, dy = p1.y - p2.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < linkDist) {
                            const alpha = Math.max(0, 1 - dist / linkDist) * 0.35; // 距离越近越亮
                            ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                }

                requestAnimationFrame(step);
            }

            window.addEventListener('resize', resize);
            resize();
            requestAnimationFrame(step);
        })();
    </script>
</body>
</html>
